<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>오목</title>
<style>
  body {
    text-align: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    background-color: #f0e6d2;
    color: #3a2a1a;
    margin: 0;
    padding: 10px;
    overscroll-behavior: none; /* iOS/Android에서 스크롤 바운스 효과 제거 */
  }
  h1 {
    margin-top: 10px;
    margin-bottom: 10px;
  }
  canvas {
    width: 100%;
    max-width: 760px;
    height: auto;
    background-color: #deb887;
    margin: 15px auto;
    display: block;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    border-radius: 8px;
    touch-action: none; /* 터치 이벤트가 페이지 스크롤 등을 유발하지 않도록 설정 */
  }
  #controls {
    margin-bottom: 15px;
    display: flex;
    /* flex-wrap: wrap; */ /* Removed to prevent line breaks for selects */
    justify-content: center;
    align-items: center;
    gap: 10px;
  }
  button, select {
    font-size: 16px;
    padding: 8px 14px;
    border-radius: 6px;
    border: 1px solid #8c6d4e;
    background-color: #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: background-color 0.2s, box-shadow 0.2s;
  }
  button:hover, select:hover {
    background-color: #fdfaf5;
  }
  button:active {
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);
  }

  /* 턴 알림 스타일 */
  #turn-indicator {
    margin-bottom: 15px;
    padding: 8px 15px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: 500;
    display: inline-block;
    transition: background-color 0.3s, color 0.3s;
  }
  .player-turn {
    background-color: #28a745;
    color: white;
  }
  .ai-turn {
    background-color: #dc3545;
    color: white;
  }
  .game-over {
      background-color: #6c757d;
      color: white;
  }

  /* 커스텀 메시지 박스 스타일 */
  #message-box {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.6);
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .message-content {
    background: #f0e6d2;
    padding: 30px 40px;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
  #message-text {
    margin: 0 0 20px 0;
    font-size: 22px;
    font-weight: 500;
    color: #3a2a1a;
  }
  #message-close-btn {
    font-size: 18px;
    padding: 10px 25px;
  }
</style>
</head>
<body>

<h1>오목 AI</h1>
<div id="turn-indicator"></div>
<div id="controls">
  <label for="playerColor">내 돌 색상:</label>
  <select id="playerColor">
    <option value="black">흑돌 (선공)</option>
    <option value="white">백돌 (후공)</option>
  </select>
  <label for="boardSize">바둑판 크기:</label>
  <select id="boardSize">
    <option value="19">19x19</option>
    <option value="15">15x15</option>
    <option value="13" selected>13x13</option>
    <option value="10">10x10</option>
  </select>
  <button id="undoBtn">무르기</button>
  <button id="resetBtn">새 게임 시작</button>
</div>
<canvas id="board" width="760" height="760"></canvas>

<div id="message-box">
  <div class="message-content">
    <p id="message-text"></p>
    <button id="message-close-btn">확인</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  
  // --- 상수 및 상태 변수 정의 ---
  let size; 
  let cellSize; 
  const directions = [[1,0], [0,1], [1,1], [1,-1]];

  let board = Array.from({ length: size }, () => Array(size).fill(null));
  let history = [];
  let currentPlayer = 'black';
  let gameOver = false;
  let playerColor = 'black';
  let aiColor = 'white';
  let audioCtx; 

  // --- UI 요소 참조 ---
  const playerColorSelect = document.getElementById('playerColor');
  const boardSizeSelect = document.getElementById('boardSize'); 
  const undoBtn = document.getElementById('undoBtn');
  const resetBtn = document.getElementById('resetBtn');
  const messageBox = document.getElementById('message-box');
  const messageText = document.getElementById('message-text');
  const messageCloseBtn = document.getElementById('message-close-btn');
  const turnIndicator = document.getElementById('turn-indicator');

  // --- 오디오 처리 ---
  function initAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  function playStoneSound() {
    if (!audioCtx) return;
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); 
    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);

    oscillator.start(audioCtx.currentTime);
    oscillator.stop(audioCtx.currentTime + 0.5);
  }

  // --- 화면 및 보드 그리기 ---
  
  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#553c23';
    ctx.lineWidth = 1;

    for (let i = 0; i < size; i++) {
      const pos = cellSize / 2 + i * cellSize;
      ctx.beginPath(); ctx.moveTo(cellSize / 2, pos); ctx.lineTo(canvas.width - cellSize / 2, pos); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(pos, cellSize / 2); ctx.lineTo(pos, canvas.height - cellSize / 2); ctx.stroke();
    }

    // 별(화점) 위치를 바둑판 크기에 따라 동적으로 변경
    let starPoints = [];
    if (size === 19) {
        starPoints = [3, 9, 15];
    } else if (size === 15) {
        starPoints = [3, 7, 11];
    } else if (size === 13) {
        starPoints = [3, 6, 9];
    } else if (size === 10) {
        starPoints = [2, 7]; 
    }
    
    ctx.fillStyle = '#553c23';
    starPoints.forEach(x => {
      starPoints.forEach(y => {
        // Only draw star points if they are within the board boundaries and are intended for the current size
        // For 10x10, drawing only the corners of the inner 4x4 square for reference
        if (size === 10) {
            if ((x === 2 && y === 2) || (x === 2 && y === 7) || (x === 7 && y === 2) || (x === 7 && y === 7)) {
                ctx.beginPath(); 
                ctx.arc(cellSize/2 + x*cellSize, cellSize/2 + y*cellSize, 5, 0, Math.PI * 2); 
                ctx.fill();
            }
        } else { // For 13, 15, 19, draw all generated star points
            ctx.beginPath(); 
            ctx.arc(cellSize/2 + x*cellSize, cellSize/2 + y*cellSize, 5, 0, Math.PI * 2); 
            ctx.fill();
        }
      });
    });

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        if (board[y][x]) {
          drawStone(x, y, board[y][x]);
        }
      }
    }

    // AI가 마지막으로 둔 돌에 마커 그리기
    if (history.length > 0) {
      const lastMove = history[history.length - 1];
      if (lastMove.color === aiColor && currentPlayer === playerColor) { // AI가 둔 마지막 돌이고 현재 플레이어 턴일 때
        drawMarker(lastMove.x, lastMove.y, aiColor);
      }
    }

    updateTurnIndicator(); 
  }

  function drawStone(x, y, color) {
    const radius = cellSize / 2.5;
    const cx = (x + 0.5) * cellSize;
    const cy = (y + 0.5) * cellSize;
    
    ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    
    const gradient = ctx.createRadialGradient(cx - radius * 0.3, cy - radius * 0.3, radius * 0.1, cx, cy, radius);

    if (color === 'black') { gradient.addColorStop(0, '#666'); gradient.addColorStop(1, '#000'); }
    else { gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ddd'); }
    
    ctx.fillStyle = gradient;
    ctx.fill();
  }

  // AI가 둔 마지막 돌에 역삼각형 마커를 그리는 함수
  function drawMarker(x, y, stoneColor) {
    const cx = (x + 0.5) * cellSize;
    const cy = (y + 0.5) * cellSize;
    const markerSize = cellSize / 4; 

    ctx.beginPath();
    ctx.moveTo(cx - markerSize, cy - markerSize / 2);
    ctx.lineTo(cx + markerSize, cy - markerSize / 2);
    ctx.lineTo(cx, cy + markerSize);
    ctx.closePath();

    ctx.fillStyle = (stoneColor === 'black') ? 'white' : 'black'; // 돌 색상에 따라 마커 색상 변경
    ctx.fill();
  }

  // --- 게임 로직 ---

  function canPlace(x, y) {
    return x >= 0 && y >= 0 && x < size && y < size && !board[y][x];
  }

  function placeStone(x, y, color) {
    if (!canPlace(x, y) || gameOver) return false;
    board[y][x] = color;
    history.push({x, y, color});
    playStoneSound(); 
    drawBoard();
    return true;
  }

  function checkWin(x, y) {
    const color = board[y][x];
    if (!color) return false;
    for (const [dx, dy] of directions) {
      let count = 1;
      for (let i = 1; i < 5; i++) { if (board[y + dy*i]?.[x + dx*i] === color) count++; else break; }
      for (let i = 1; i < 5; i++) { if (board[y - dy*i]?.[x - dx*i] === color) count++; else break; }
      if (count >= 5) return true;
    }
    return false;
  }

  function undo() {
    if (gameOver) return;
    const movesToUndo = (currentPlayer === playerColor && history.length >= 2) ? 2 : 1; 
    
    if (history.length < movesToUndo) return;

    for (let i = 0; i < movesToUndo; i++) {
        const lastMove = history.pop();
        if (lastMove) board[lastMove.y][lastMove.x] = null;
    }
    currentPlayer = playerColor; 
    gameOver = false;
    drawBoard();
  }
  
  function resetGame() {
    size = parseInt(boardSizeSelect.value, 10);
    cellSize = canvas.width / size;

    board = Array.from({ length: size }, () => Array(size).fill(null));
    history = [];
    gameOver = false;
    playerColor = playerColorSelect.value;
    aiColor = playerColor === 'black' ? 'white' : 'black';
    currentPlayer = 'black';
    drawBoard();

    if (playerColor === 'white') {
      setTimeout(aiMove, 300);
    }
  }

  function updateTurnIndicator() {
      if (gameOver) {
          turnIndicator.textContent = "게임 종료";
          turnIndicator.className = 'game-over';
      } else if (currentPlayer === playerColor) {
          turnIndicator.textContent = "당신의 턴";
          turnIndicator.className = 'player-turn';
      } else {
          turnIndicator.textContent = "AI가 생각 중...";
          turnIndicator.className = 'ai-turn';
      }
  }

  // --- AI 로직 ---
  // (기존 AI 로직 함수들은 공간을 위해 축약함)
  isWinBoard=function(b,x,y,c){for(const[dx,dy]of directions){let n=1;for(let i=1;i<5;i++){if(b[y+dy*i]?.[x+dx*i]===c)n++;else break}for(let i=1;i<5;i++){if(b[y-dy*i]?.[x-dx*i]===c)n++;else break}if(n>=5)return!0}return!1};
  generateMoves=function(b){const m=[],h=b.some(r=>r.some(c=>c!==null));if(!h)return m.push({x:Math.floor(size/2),y:Math.floor(size/2)}),m;const s=new Set;for(let y=0;y<size;y++)for(let x=0;x<size;x++){if(b[y][x]===null)continue;for(let dy=-2;dy<=2;dy++)for(let dx=-2;dx<=2;dx++){if(dx===0&&dy===0)continue;const nx=x+dx,ny=y+dy;if(canPlace(nx,ny)&&b[ny][nx]===null)s.add(`${nx},${ny}`)}}return s.forEach(v=>{const[x,y]=v.split(',').map(Number);m.push({x,y})}),m};
  evaluateLine=function(l){let s=0;const a=l.filter(c=>c===aiColor).length,p=l.filter(c=>c===playerColor).length,e=l.filter(c=>c===null).length;return a===4&&e===1?s+=1e4:a===3&&e===2?s+=1e3:a===2&&e===3&&(s+=100),p===4&&e===1?s-=2e4:p===3&&e==='2'?s-=5e3:p===2&&e===3&&(s-=200),s};
  evaluateBoard=function(b){let t=0;for(let i=0;i<size;i++)for(let j=0;j<size-4;j++)t+=evaluateLine(b[i].slice(j,j+5)),t+=evaluateLine([b[j][i],b[j+1][i],b[j+2][i],b[j+3][i],b[j+4][i]]);for(let i=0;i<size-4;i++)for(let j=0;j<size-4;j++)t+=evaluateLine([b[i][j],b[i+1][j+1],b[i+2][j+2],b[i+3][j+3],b[i+4][j+4]]),t+=evaluateLine([b[i+4][j],b[i+3][j+1],b[i+2][j+2],b[i+1][j+3],b[i][j+4]]);return t};
  
  // minimax 시간 제한을 동적으로 변경
  minimax=function(b,d,alpha,beta,m,startTimeForAiMove, maxAllowedTimeForAiMove){
    if(d===0 || Date.now() - startTimeForAiMove > maxAllowedTimeForAiMove) return evaluateBoard(b);
    const v=generateMoves(b);
    if(v.length===0)return 0;
    if(m){
      let e=-1/0;
      for(const o of v){
        const n=b.map(r=>r.slice());
        if(n[o.y][o.x]=aiColor,isWinBoard(n,o.x,o.y,aiColor))return 1e6;
        const c=minimax(n,d-1,alpha,beta,!1,startTimeForAiMove, maxAllowedTimeForAiMove);
        e=Math.max(e,c),alpha=Math.max(alpha,c);
        if(beta<=alpha)break
      }
      return e
    }else{
      let e=1/0;
      for(const o of v){
        const n=b.map(r=>r.slice());
        if(n[o.y][o.x]=playerColor,isWinBoard(n,o.x,o.y,playerColor))return-1e6;
        const c=minimax(n,d-1,alpha,beta,!0,startTimeForAiMove, maxAllowedTimeForAiMove);
        e=Math.min(e,c),beta=Math.min(beta,c);
        if(beta<=alpha)break
      }
      return e
    }
  };
  
  // aiMove 함수를 반복적 깊이 확장을 사용하고 동적 시간 제한 적용
  aiMove=function(){
    if(gameOver)return;
    const startTime=Date.now(); // AI 턴 시작 시간 기록
    const candidateMoves=generateMoves(board); // 가능한 모든 수 생성
    if(candidateMoves.length===0)return showMessage("무승부!"),void(gameOver=!0);

    let currentAIMoveTimeLimit; // AI 턴 전체에 할당된 시간 (ms)
    const minimaxTimeBuffer = 500; // minimax 함수가 실제 탐색을 수행할 시간 (AI 턴 전체 시간 - 버퍼)

    if (size === 10) {
        currentAIMoveTimeLimit = 4000; // 10x10 보드는 4초 고정
    } else {
        const movesCount = history.length;
        if (movesCount <= 5) {
            currentAIMoveTimeLimit = 5000; // 초반 5수까지는 5초
        } else if (movesCount <= 10) {
            currentAIMoveTimeLimit = 7000; // 10수까지는 7초
        } else {
            currentAIMoveTimeLimit = 8000; // 그 이후는 8초
        }
    }
    const minimaxAllowedTime = currentAIMoveTimeLimit - minimaxTimeBuffer;


    // 13, 15, 19 격자에서 AI의 첫 2수 제한
    if ((size === 13 || size === 15 || size === 19) && history.length <= 1) {
      const center_x = Math.floor(size / 2);
      const center_y = Math.floor(size / 2);
      const range_radius = 2; // 중앙 5x5 범위 (중앙으로부터 2칸)
      const min_cx = Math.max(0, center_x - range_radius);
      const max_cx = Math.min(size - 1, center_x + range_radius);
      const min_cy = Math.max(0, center_y - range_radius);
      const max_cy = Math.min(size - 1, center_y + range_radius);

      const isWithinCenterRange = (x, y) => {
          return x >= min_cx && x <= max_cx && y >= min_cy && y <= max_cy;
      };

      // AI의 첫 착수 (AI가 흑돌, 보드가 비어있을 때)
      if (history.length === 0 && aiColor === 'black') {
          let centerMoves = [];
          for (let y = min_cy; y <= max_cy; y++) {
              for (let x = min_cx; x <= max_cx; x++) {
                  if (canPlace(x, y)) {
                      centerMoves.push({x, y});
                  }
              }
          }
          if (centerMoves.length > 0) {
              // 정확한 중앙점을 우선 고려, 없으면 범위 내 랜덤 선택
              const exactCenterMove = centerMoves.find(m => m.x === center_x && m.y === center_y);
              let chosenMove = exactCenterMove || centerMoves[Math.floor(Math.random() * centerMoves.length)];
              
              return placeAndCheckWin(chosenMove.x, chosenMove.y, aiColor);
          }
      } 
      // AI의 두 번째 착수 (플레이어가 첫 수를 두었고, AI가 백돌, 플레이어의 첫 수가 중앙 범위 내일 때)
      else if (history.length === 1 && aiColor === 'white') {
          const playerFirstMove = history[0];
          if (isWithinCenterRange(playerFirstMove.x, playerFirstMove.y)) {
              let centerMoves = [];
              for (let y = min_cy; y <= max_cy; y++) {
                  for (let x = min_cx; x <= max_cx; x++) {
                      if (canPlace(x, y)) {
                          centerMoves.push({x, y});
                      }
                  }
              }
              if (centerMoves.length > 0) {
                  // 중앙 범위 내에서 랜덤하게 선택
                  let chosenMove = centerMoves[Math.floor(Math.random() * centerMoves.length)];
                  return placeAndCheckWin(chosenMove.x, chosenMove.y, aiColor);
              }
          }
      }
    }
    // --- 첫 2수 제한 로직 끝 ---

    let bestMove = candidateMoves[0]; // 초기 최선의 수를 첫 번째 후보로 설정
    
    // 즉각적인 승리 또는 상대방의 승리 방지 수 우선 확인
    for(const move of candidateMoves){
        const testBoard = board.map(row => row.slice());
        testBoard[move.y][move.x] = aiColor;
        if(isWinBoard(testBoard, move.x, move.y, aiColor)){
            return placeAndCheckWin(move.x, move.y, aiColor); // AI가 이기는 수 발견 시 즉시 착수
        }
    }
    for(const move of candidateMoves){
        const testBoard = board.map(row => row.slice());
        testBoard[move.y][move.x] = playerColor;
        if(isWinBoard(testBoard, move.x, move.y, playerColor)){
            bestMove = move; // 상대방의 승리를 막는 수 발견 시, 그 수를 최선으로 설정 후 착수
            return placeAndCheckWin(bestMove.x, bestMove.y, aiColor);
        }
    }

    let currentDepth = 1; // 탐색 시작 깊이
    let lastValidBestMove = bestMove; // 마지막으로 성공적으로 탐색된 깊이에서의 최선수

    // 반복적 깊이 확장 루프
    // 동적으로 설정된 AI 턴 시간 내에서 가능한 한 깊이 탐색
    while (Date.now() - startTime < currentAIMoveTimeLimit) { 
        let bestScoreForCurrentDepth = -Infinity;
        let bestMoveForCurrentDepth = null;
        let anyMoveEvaluatedAtCurrentDepth = false; // 현재 깊이에서 어떤 수라도 평가되었는지

        // 현재 깊이에서 모든 후보 수를 탐색
        for (const move of candidateMoves) {
            // 각 수 평가 전 전체 시간 제한 다시 확인
            if (Date.now() - startTime > currentAIMoveTimeLimit) {
                break; // 시간 초과 시 현재 깊이 탐색 중단
            }

            const tempBoard = board.map(row => row.slice());
            tempBoard[move.y][move.x] = aiColor;
            
            // minimax 호출. (minimax 자체도 시간 제한이 있음)
            const score = minimax(tempBoard, currentDepth - 1, -Infinity, Infinity, false, startTime, minimaxAllowedTime); 

            if (score > bestScoreForCurrentDepth) {
                bestScoreForCurrentDepth = score;
                bestMoveForCurrentDepth = move;
            }
            anyMoveEvaluatedAtCurrentDepth = true;
        }

        if (!anyMoveEvaluatedAtCurrentDepth || (Date.now() - startTime > currentAIMoveTimeLimit && currentDepth > 1)) {
             // 현재 깊이 탐색이 완료되지 않았거나 시간 초과 시, 마지막으로 완료된 깊이의 최선수 사용
            break;
        } else {
            // 현재 깊이 탐색이 성공적으로 완료됨
            if (bestMoveForCurrentDepth) {
                lastValidBestMove = bestMoveForCurrentDepth; // 최선수 업데이트
            }
            currentDepth++; // 다음 반복에서 더 깊이 탐색
            if (currentDepth > 5) { // 무한정 깊어지는 것을 방지하기 위한 최대 깊이 제한
                break; 
            }
        }
    }
    
    // 최종적으로 찾은 최선수에 착수 (시간 내에 아무것도 못 찾았을 경우 초기 후보수 사용)
    bestMove = lastValidBestMove || candidateMoves[0]; 

    placeAndCheckWin(bestMove.x, bestMove.y, aiColor);
  };

  /**
   * ✅ 수정된 함수 1: placeAndCheckWin
   * 플레이어 변경 후 턴 표시를 즉시 업데이트하도록 수정
   */
  function placeAndCheckWin(x, y, color) {
    placeStone(x, y, color);
    if (checkWin(x, y)) {
        showMessage( (color === playerColor ? "플레이어" : "AI") + " 승리!");
        gameOver = true;
        updateTurnIndicator(); 
    } else {
        currentPlayer = (color === playerColor) ? aiColor : playerColor;
        drawBoard(); // 마커를 다시 그리기 위해 drawBoard 호출
        updateTurnIndicator();
    }
  }

  // --- 이벤트 핸들러 ---
  /**
   * ✅ 수정된 함수 2: handleClick
   * placeAndCheckWin에서 턴 표시를 업데이트하므로 중복되는 코드 제거
   */
  function handleClick(e) {
    if (gameOver || currentPlayer !== playerColor) return;
    e.preventDefault();
    initAudio(); 

    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
    
    let clientX, clientY;
    if (e.touches) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
    else { clientX = e.clientX; clientY = e.clientY; }
    
    const x = (clientX - rect.left) * scaleX; const y = (clientY - rect.top) * scaleY;
    const cx = Math.floor(x / cellSize); const cy = Math.floor(y / cellSize);

    if (!canPlace(cx, cy)) return;
    
    placeAndCheckWin(cx, cy, playerColor);

    if (!gameOver) {
      setTimeout(aiMove, 100);
    }
  }
  
  function showMessage(msg) {
    messageText.textContent = msg;
    messageBox.style.display = 'flex';
  }

  // --- 이벤트 리스너 등록 ---
  canvas.addEventListener('mousedown', handleClick);
  canvas.addEventListener('touchstart', handleClick);
  undoBtn.addEventListener('click', undo);
  resetBtn.addEventListener('click', resetGame);
  playerColorSelect.addEventListener('change', resetGame);
  boardSizeSelect.addEventListener('change', resetGame); 
  messageCloseBtn.addEventListener('click', () => { messageBox.style.display = 'none'; });
  window.addEventListener('resize', drawBoard);

  // --- 초기화 ---
  resetGame();

})();
</script>

</body>
</html>