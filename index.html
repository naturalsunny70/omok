<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>오목 AI</title>
<style>
  body {
    text-align: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    background-color: #f0e6d2;
    color: #3a2a1a;
    margin: 0;
    padding: 10px;
    overscroll-behavior: none; /* iOS/Android에서 스크롤 바운스 효과 제거 */
  }
  h1 {
    margin-top: 10px;
    margin-bottom: 10px;
  }
  canvas {
    width: 100%;
    max-width: 760px;
    height: auto;
    background-color: #deb887;
    margin: 15px auto;
    display: block;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    border-radius: 8px;
    touch-action: none; /* 터치 이벤트가 페이지 스크롤 등을 유발하지 않도록 설정 */
  }
  #controls {
    margin-bottom: 10px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 10px;
  }
  button, select {
    font-size: 16px;
    padding: 8px 14px;
    border-radius: 6px;
    border: 1px solid #8c6d4e;
    background-color: #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: background-color 0.2s, box-shadow 0.2s;
  }
  button:hover, select:hover {
    background-color: #fdfaf5;
  }
  button:active {
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);
  }

  /* 커스텀 메시지 박스 스타일 */
  #message-box {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.6);
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .message-content {
    background: #f0e6d2;
    padding: 30px 40px;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
  #message-text {
    margin: 0 0 20px 0;
    font-size: 22px;
    font-weight: 500;
    color: #3a2a1a;
  }
  #message-close-btn {
    font-size: 18px;
    padding: 10px 25px;
  }
</style>
</head>
<body>

<h1>오목 AI</h1>
<div id="controls">
  <label for="playerColor">내 돌 색상:</label>
  <select id="playerColor">
    <option value="black">흑돌 (선공)</option>
    <option value="white">백돌 (후공)</option>
  </select>
  <button id="undoBtn">무르기</button>
  <button id="resetBtn">재시작</button>
</div>
<canvas id="board" width="760" height="760"></canvas>

<!-- 커스텀 메시지 박스 HTML -->
<div id="message-box">
  <div class="message-content">
    <p id="message-text"></p>
    <button id="message-close-btn">확인</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  
  // --- 상수 및 상태 변수 정의 ---
  const size = 19; // 바둑판 크기 (19x19)
  const cellSize = canvas.width / size; // 각 칸의 크기
  const directions = [[1,0], [0,1], [1,1], [1,-1]]; // 4방향 (가로, 세로, 대각선)

  let board = Array.from({ length: size }, () => Array(size).fill(null));
  let history = [];
  let currentPlayer = 'black';
  let gameOver = false;
  let playerColor = 'black';
  let aiColor = 'white';

  // --- UI 요소 참조 ---
  const playerColorSelect = document.getElementById('playerColor');
  const undoBtn = document.getElementById('undoBtn');
  const resetBtn = document.getElementById('resetBtn');
  const messageBox = document.getElementById('message-box');
  const messageText = document.getElementById('message-text');
  const messageCloseBtn = document.getElementById('message-close-btn');

  // --- 화면 및 보드 그리기 ---
  
  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#553c23';
    ctx.lineWidth = 1;

    // 바둑판 선 그리기
    for (let i = 0; i < size; i++) {
      const pos = cellSize / 2 + i * cellSize;
      // 가로선
      ctx.beginPath();
      ctx.moveTo(cellSize / 2, pos);
      ctx.lineTo(canvas.width - cellSize / 2, pos);
      ctx.stroke();
      // 세로선
      ctx.beginPath();
      ctx.moveTo(pos, cellSize / 2);
      ctx.lineTo(pos, canvas.height - cellSize / 2);
      ctx.stroke();
    }

    // 화점(별점) 그리기
    const starPoints = [3, 9, 15];
    ctx.fillStyle = '#553c23';
    starPoints.forEach(x => {
      starPoints.forEach(y => {
        ctx.beginPath();
        ctx.arc(cellSize/2 + x*cellSize, cellSize/2 + y*cellSize, 5, 0, Math.PI * 2);
        ctx.fill();
      });
    });

    // 놓인 돌들 그리기
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        if (board[y][x]) {
          drawStone(x, y, board[y][x]);
        }
      }
    }
  }

  function drawStone(x, y, color) {
    const radius = cellSize / 2.5;
    const cx = (x + 0.5) * cellSize;
    const cy = (y + 0.5) * cellSize;
    
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    
    const gradient = ctx.createRadialGradient(cx - radius * 0.3, cy - radius * 0.3, radius * 0.1, cx, cy, radius);

    if (color === 'black') {
      gradient.addColorStop(0, '#666');
      gradient.addColorStop(1, '#000');
    } else {
      gradient.addColorStop(0, '#fff');
      gradient.addColorStop(1, '#ddd');
    }
    
    ctx.fillStyle = gradient;
    ctx.fill();
  }

  // --- 게임 로직 ---

  function canPlace(x, y) {
    if (x < 0 || y < 0 || x >= size || y >= size) return false;
    return !board[y][x];
  }

  function placeStone(x, y, color) {
    if (!canPlace(x, y) || gameOver) return false;
    board[y][x] = color;
    history.push({x, y, color});
    drawBoard();
    return true;
  }

  function checkWin(x, y) {
    const color = board[y][x];
    if (!color) return false;

    for (const [dx, dy] of directions) {
      let count = 1;
      // 한쪽 방향으로 검사
      for (let i = 1; i < 5; i++) {
        const nx = x + dx * i;
        const ny = y + dy * i;
        if (board[ny]?.[nx] === color) count++;
        else break;
      }
      // 반대쪽 방향으로 검사
      for (let i = 1; i < 5; i++) {
        const nx = x - dx * i;
        const ny = y - dy * i;
        if (board[ny]?.[nx] === color) count++;
        else break;
      }
      if (count >= 5) return true;
    }
    return false;
  }

  function undo() {
    if (gameOver) return;
    // 플레이어가 흑돌(선공)이면 2개, 백돌(후공)이면 2개를 무릅니다.
    // 단, 게임 시작 직후 AI가 두기 전이면 1개만 무릅니다.
    const movesToUndo = (history.length > 1 && playerColor !== currentPlayer) ? 2 : 1;
    if (history.length < movesToUndo) return;

    for (let i = 0; i < movesToUndo; i++) {
        const lastMove = history.pop();
        if (lastMove) {
            board[lastMove.y][lastMove.x] = null;
        }
    }

    currentPlayer = playerColor;
    gameOver = false;
    drawBoard();
  }
  
  function resetGame() {
    board = Array.from({ length: size }, () => Array(size).fill(null));
    history = [];
    gameOver = false;
    playerColor = playerColorSelect.value;
    aiColor = playerColor === 'black' ? 'white' : 'black';
    currentPlayer = 'black';
    drawBoard();

    if (playerColor === 'white') {
      setTimeout(aiMove, 300);
    }
  }

  // --- AI 로직 ---
  
  function isWinBoard(boardState, x, y, color) {
    for (const [dx, dy] of directions) {
      let count = 1;
      for(let i=1; i<5; i++) { if(boardState[y + dy*i]?.[x + dx*i] === color) count++; else break; }
      for(let i=1; i<5; i++) { if(boardState[y - dy*i]?.[x - dx*i] === color) count++; else break; }
      if (count >= 5) return true;
    }
    return false;
  }
  
  function generateMoves(boardState) {
    const moves = [];
    const hasStone = boardState.some(row => row.some(cell => cell !== null));
    
    if (!hasStone) {
        // 판이 비어있으면 중앙에 둡니다.
        moves.push({ x: Math.floor(size/2), y: Math.floor(size/2) });
        return moves;
    }

    const moveSet = new Set();
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        if (boardState[y][x] === null) continue;
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx;
            const ny = y + dy;
            if (canPlace(nx, ny) && boardState[ny][nx] === null) {
              moveSet.add(`${nx},${ny}`);
            }
          }
        }
      }
    }
    moveSet.forEach(move => {
        const [x, y] = move.split(',').map(Number);
        moves.push({x, y});
    });
    return moves;
  }
  
  function evaluateLine(line) {
    let score = 0;
    const aiCount = line.filter(c => c === aiColor).length;
    const playerCount = line.filter(c => c === playerColor).length;
    const emptyCount = line.filter(c => c === null).length;

    if (aiCount === 4 && emptyCount === 1) score += 10000;
    else if (aiCount === 3 && emptyCount === 2) score += 1000;
    else if (aiCount === 2 && emptyCount === 3) score += 100;
    
    if (playerCount === 4 && emptyCount === 1) score -= 20000;
    else if (playerCount === 3 && emptyCount === 2) score -= 5000;
    else if (playerCount === 2 && emptyCount === 3) score -= 200;
    
    return score;
  }

  function evaluateBoard(boardState) {
      let totalScore = 0;
      for (let i = 0; i < size; i++) {
          for (let j = 0; j < size - 4; j++) {
              // 가로
              totalScore += evaluateLine(boardState[i].slice(j, j + 5));
              // 세로
              totalScore += evaluateLine([boardState[j][i], boardState[j+1][i], boardState[j+2][i], boardState[j+3][i], boardState[j+4][i]]);
          }
      }
      // 대각선
      for (let i = 0; i < size - 4; i++) {
          for (let j = 0; j < size - 4; j++) {
              totalScore += evaluateLine([boardState[i][j], boardState[i+1][j+1], boardState[i+2][j+2], boardState[i+3][j+3], boardState[i+4][j+4]]);
              totalScore += evaluateLine([boardState[i+4][j], boardState[i+3][j+1], boardState[i+2][j+2], boardState[i+1][j+3], boardState[i][j+4]]);
          }
      }
      return totalScore;
  }
  
  function minimax(boardState, depth, alpha, beta, maximizing, startTime) {
    if (depth === 0 || Date.now() - startTime > 9500) { // 시간제한 9.5초
      return evaluateBoard(boardState);
    }

    const moves = generateMoves(boardState);
    if (moves.length === 0) return 0;
    
    if (maximizing) {
      let maxEval = -Infinity;
      for (const move of moves) {
        const newBoard = boardState.map(r => r.slice());
        newBoard[move.y][move.x] = aiColor;
        if(isWinBoard(newBoard, move.x, move.y, aiColor)) return 1000000;
        const evalScore = minimax(newBoard, depth - 1, alpha, beta, false, startTime);
        maxEval = Math.max(maxEval, evalScore);
        alpha = Math.max(alpha, evalScore);
        if (beta <= alpha) break;
      }
      return maxEval;
    } else {
      let minEval = Infinity;
      for (const move of moves) {
        const newBoard = boardState.map(r => r.slice());
        newBoard[move.y][move.x] = playerColor;
        if(isWinBoard(newBoard, move.x, move.y, playerColor)) return -1000000;
        const evalScore = minimax(newBoard, depth - 1, alpha, beta, true, startTime);
        minEval = Math.min(minEval, evalScore);
        beta = Math.min(beta, evalScore);
        if (beta <= alpha) break;
      }
      return minEval;
    }
  }
  
  function aiMove() {
    if (gameOver) return;
    const startTime = Date.now();
    const moves = generateMoves(board);
    
    if (moves.length === 0) {
        showMessage("무승부!");
        gameOver = true;
        return;
    }

    let bestMove = moves[0];
    
    // 1. AI가 이길 수 있는 수가 있는지 확인
    for (const move of moves) {
      const tempBoard = board.map(r => r.slice());
      tempBoard[move.y][move.x] = aiColor;
      if (isWinBoard(tempBoard, move.x, move.y, aiColor)) {
        bestMove = move;
        placeAndCheckWin(bestMove.x, bestMove.y, aiColor);
        return;
      }
    }
    
    // 2. 플레이어가 이길 수 있는 수가 있는지 확인하고 막기
    for (const move of moves) {
      const tempBoard = board.map(r => r.slice());
      tempBoard[move.y][move.x] = playerColor;
      if (isWinBoard(tempBoard, move.x, move.y, playerColor)) {
        bestMove = move;
        placeAndCheckWin(bestMove.x, bestMove.y, aiColor);
        return;
      }
    }

    // 3. 미니맥스 탐색
    let bestScore = -Infinity;
    for (const move of moves) {
      const newBoard = board.map(r => r.slice());
      newBoard[move.y][move.x] = aiColor;
      const score = minimax(newBoard, 2, -Infinity, Infinity, false, startTime); // Depth 2로 제한
      if (score > bestScore) {
        bestScore = score;
        bestMove = move;
      }
    }

    placeAndCheckWin(bestMove.x, bestMove.y, aiColor);
  }

  function placeAndCheckWin(x, y, color) {
    placeStone(x, y, color);
    if (checkWin(x, y)) {
        showMessage( (color === playerColor ? "플레이어" : "AI") + " 승리!");
        gameOver = true;
    } else {
        currentPlayer = (color === playerColor) ? aiColor : playerColor;
    }
  }


  // --- 이벤트 핸들러 ---
  
  function handleClick(e) {
    if (gameOver || currentPlayer !== playerColor) return;
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    
    // CSS 스케일을 고려하여 정확한 캔버스 좌표 계산
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    let clientX, clientY;
    if (e.touches) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    
    const x = (clientX - rect.left) * scaleX;
    const y = (clientY - rect.top) * scaleY;

    const cx = Math.floor(x / cellSize);
    const cy = Math.floor(y / cellSize);

    if (!canPlace(cx, cy)) return;
    
    placeAndCheckWin(cx, cy, playerColor);

    if (!gameOver) {
      setTimeout(aiMove, 100);
    }
  }
  
  function showMessage(msg) {
    messageText.textContent = msg;
    messageBox.style.display = 'flex';
  }

  // --- 이벤트 리스너 등록 ---
  canvas.addEventListener('mousedown', handleClick);
  canvas.addEventListener('touchstart', handleClick);

  undoBtn.addEventListener('click', undo);
  resetBtn.addEventListener('click', resetGame);
  playerColorSelect.addEventListener('change', resetGame);
  
  messageCloseBtn.addEventListener('click', () => {
    messageBox.style.display = 'none';
  });

  window.addEventListener('resize', () => {
    // 화면 크기가 변경될 때마다 보드를 다시 그림 (스케일은 CSS로 자동조정됨)
    drawBoard();
  });

  // --- 초기화 ---
  resetGame();

})();
</script>

</body>
</html>
