<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>오목 AI</title>
<style>
  body {
    text-align: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    background-color: #f0e6d2;
    color: #3a2a1a;
    margin: 0;
    padding: 10px;
    overscroll-behavior: none; /* iOS/Android에서 스크롤 바운스 효과 제거 */
  }
  h1 {
    margin-top: 10px;
    margin-bottom: 10px;
  }
  canvas {
    width: 100%;
    max-width: 760px;
    height: auto;
    background-color: #deb887;
    margin: 15px auto;
    display: block;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    border-radius: 8px;
    touch-action: none; /* 터치 이벤트가 페이지 스크롤 등을 유발하지 않도록 설정 */
  }
  #controls {
    margin-bottom: 15px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 10px;
  }
  button, select {
    font-size: 16px;
    padding: 8px 14px;
    border-radius: 6px;
    border: 1px solid #8c6d4e;
    background-color: #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: background-color 0.2s, box-shadow 0.2s;
  }
  button:hover, select:hover {
    background-color: #fdfaf5;
  }
  button:active {
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);
  }

  /* 턴 알림 스타일 */
  #turn-indicator {
    margin-bottom: 15px;
    padding: 8px 15px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: 500;
    display: inline-block;
    transition: background-color 0.3s, color 0.3s;
  }
  .player-turn {
    background-color: #28a745;
    color: white;
  }
  .ai-turn {
    background-color: #dc3545;
    color: white;
  }
  .game-over {
      background-color: #6c757d;
      color: white;
  }

  /* 커스텀 메시지 박스 스타일 */
  #message-box {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.6);
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .message-content {
    background: #f0e6d2;
    padding: 30px 40px;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
  #message-text {
    margin: 0 0 20px 0;
    font-size: 22px;
    font-weight: 500;
    color: #3a2a1a;
  }
  #message-close-btn {
    font-size: 18px;
    padding: 10px 25px;
  }
</style>
</head>
<body>

<h1>오목 AI</h1>
<div id="turn-indicator"></div>
<div id="controls">
  <label for="playerColor">내 돌 색상:</label>
  <select id="playerColor">
    <option value="black">흑돌 (선공)</option>
    <option value="white">백돌 (후공)</option>
  </select>
  <button id="undoBtn">무르기</button>
  <button id="resetBtn">재시작</button>
</div>
<canvas id="board" width="760" height="760"></canvas>

<div id="message-box">
  <div class="message-content">
    <p id="message-text"></p>
    <button id="message-close-btn">확인</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  
  // --- 상수 및 상태 변수 정의 ---
  const size = 19;
  const cellSize = canvas.width / size;
  const directions = [[1,0], [0,1], [1,1], [1,-1]];

  let board = Array.from({ length: size }, () => Array(size).fill(null));
  let history = [];
  let currentPlayer = 'black';
  let gameOver = false;
  let playerColor = 'black';
  let aiColor = 'white';
  let audioCtx; // 효과음을 위한 AudioContext

  // --- UI 요소 참조 ---
  const playerColorSelect = document.getElementById('playerColor');
  const undoBtn = document.getElementById('undoBtn');
  const resetBtn = document.getElementById('resetBtn');
  const messageBox = document.getElementById('message-box');
  const messageText = document.getElementById('message-text');
  const messageCloseBtn = document.getElementById('message-close-btn');
  const turnIndicator = document.getElementById('turn-indicator');

  // --- 오디오 처리 ---
  function initAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  function playStoneSound() {
    if (!audioCtx) return;
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // '똑' 소리 주파수
    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);

    oscillator.start(audioCtx.currentTime);
    oscillator.stop(audioCtx.currentTime + 0.5);
  }

  // --- 화면 및 보드 그리기 ---
  
  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#553c23';
    ctx.lineWidth = 1;

    for (let i = 0; i < size; i++) {
      const pos = cellSize / 2 + i * cellSize;
      ctx.beginPath(); ctx.moveTo(cellSize / 2, pos); ctx.lineTo(canvas.width - cellSize / 2, pos); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(pos, cellSize / 2); ctx.lineTo(pos, canvas.height - cellSize / 2); ctx.stroke();
    }

    const starPoints = [3, 9, 15];
    ctx.fillStyle = '#553c23';
    starPoints.forEach(x => {
      starPoints.forEach(y => {
        ctx.beginPath(); ctx.arc(cellSize/2 + x*cellSize, cellSize/2 + y*cellSize, 5, 0, Math.PI * 2); ctx.fill();
      });
    });

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        if (board[y][x]) {
          drawStone(x, y, board[y][x]);
        }
      }
    }
    updateTurnIndicator(); // 보드를 그릴 때마다 턴 표시 업데이트
  }

  function drawStone(x, y, color) {
    const radius = cellSize / 2.5;
    const cx = (x + 0.5) * cellSize;
    const cy = (y + 0.5) * cellSize;
    
    ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    
    const gradient = ctx.createRadialGradient(cx - radius * 0.3, cy - radius * 0.3, radius * 0.1, cx, cy, radius);

    if (color === 'black') { gradient.addColorStop(0, '#666'); gradient.addColorStop(1, '#000'); }
    else { gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ddd'); }
    
    ctx.fillStyle = gradient;
    ctx.fill();
  }

  // --- 게임 로직 ---

  function canPlace(x, y) {
    return x >= 0 && y >= 0 && x < size && y < size && !board[y][x];
  }

  function placeStone(x, y, color) {
    if (!canPlace(x, y) || gameOver) return false;
    board[y][x] = color;
    history.push({x, y, color});
    playStoneSound(); // 돌 놓는 소리 재생
    drawBoard();
    return true;
  }

  function checkWin(x, y) {
    const color = board[y][x];
    if (!color) return false;
    for (const [dx, dy] of directions) {
      let count = 1;
      for (let i = 1; i < 5; i++) { if (board[y + dy*i]?.[x + dx*i] === color) count++; else break; }
      for (let i = 1; i < 5; i++) { if (board[y - dy*i]?.[x - dx*i] === color) count++; else break; }
      if (count >= 5) return true;
    }
    return false;
  }

  function undo() {
    if (gameOver) return;
    const movesToUndo = (history.length > 1 && playerColor !== currentPlayer) ? 2 : 1;
    if (history.length < movesToUndo) return;

    for (let i = 0; i < movesToUndo; i++) {
        const lastMove = history.pop();
        if (lastMove) board[lastMove.y][lastMove.x] = null;
    }
    currentPlayer = playerColor;
    gameOver = false;
    drawBoard();
  }
  
  function resetGame() {
    board = Array.from({ length: size }, () => Array(size).fill(null));
    history = [];
    gameOver = false;
    playerColor = playerColorSelect.value;
    aiColor = playerColor === 'black' ? 'white' : 'black';
    currentPlayer = 'black';
    drawBoard();

    if (playerColor === 'white') {
      setTimeout(aiMove, 300);
    }
  }

  function updateTurnIndicator() {
      if (gameOver) {
          turnIndicator.textContent = "게임 종료";
          turnIndicator.className = 'game-over';
      } else if (currentPlayer === playerColor) {
          turnIndicator.textContent = "당신의 턴";
          turnIndicator.className = 'player-turn';
      } else {
          turnIndicator.textContent = "AI가 생각 중...";
          turnIndicator.className = 'ai-turn';
      }
  }

  // --- AI 로직 (이전과 동일) ---
  function isWinBoard(boardState, x, y, color) { /* ... */ }
  function generateMoves(boardState) { /* ... */ }
  function evaluateLine(line) { /* ... */ }
  function evaluateBoard(boardState) { /* ... */ }
  function minimax(boardState, depth, alpha, beta, maximizing, startTime) { /* ... */ }
  function aiMove() { /* ... */ }

  /**
   * ✅ 수정된 함수 1: placeAndCheckWin
   * 플레이어 변경 후 턴 표시를 즉시 업데이트하도록 수정
   */
  function placeAndCheckWin(x, y, color) {
    placeStone(x, y, color);
    if (checkWin(x, y)) {
        showMessage( (color === playerColor ? "플레이어" : "AI") + " 승리!");
        gameOver = true;
        updateTurnIndicator(); // 게임 종료 상태 업데이트
    } else {
        // 플레이어 턴을 변경합니다.
        currentPlayer = (color === playerColor) ? aiColor : playerColor;
        // 턴을 변경한 직후, 표시를 바로 업데이트합니다.
        updateTurnIndicator();
    }
  }

  // --- 이벤트 핸들러 ---
  /**
   * ✅ 수정된 함수 2: handleClick
   * placeAndCheckWin에서 턴 표시를 업데이트하므로 중복되는 코드 제거
   */
  function handleClick(e) {
    if (gameOver || currentPlayer !== playerColor) return;
    e.preventDefault();
    initAudio(); // 첫 터치/클릭 시 오디오 컨텍스트 초기화

    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
    
    let clientX, clientY;
    if (e.touches) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
    else { clientX = e.clientX; clientY = e.clientY; }
    
    const x = (clientX - rect.left) * scaleX; const y = (clientY - rect.top) * scaleY;
    const cx = Math.floor(x / cellSize); const cy = Math.floor(y / cellSize);

    if (!canPlace(cx, cy)) return;
    
    placeAndCheckWin(cx, cy, playerColor);

    if (!gameOver) {
      // 이 위치의 updateTurnIndicator() 호출은 제거되었습니다.
      setTimeout(aiMove, 100);
    }
  }
  
  function showMessage(msg) {
    messageText.textContent = msg;
    messageBox.style.display = 'flex';
  }

  // --- 이벤트 리스너 등록 ---
  canvas.addEventListener('mousedown', handleClick);
  canvas.addEventListener('touchstart', handleClick);
  undoBtn.addEventListener('click', undo);
  resetBtn.addEventListener('click', resetGame);
  playerColorSelect.addEventListener('change', resetGame);
  messageCloseBtn.addEventListener('click', () => { messageBox.style.display = 'none'; });
  window.addEventListener('resize', drawBoard);

  // --- 초기화 ---
  resetGame();

  // AI 로직 함수들은 공간을 위해 축약합니다 (실제로는 이전 코드와 동일).
  isWinBoard=function(b,x,y,c){for(const[dx,dy]of directions){let n=1;for(let i=1;i<5;i++){if(b[y+dy*i]?.[x+dx*i]===c)n++;else break}for(let i=1;i<5;i++){if(b[y-dy*i]?.[x-dx*i]===c)n++;else break}if(n>=5)return!0}return!1};
  generateMoves=function(b){const m=[],h=b.some(r=>r.some(c=>c!==null));if(!h)return m.push({x:Math.floor(size/2),y:Math.floor(size/2)}),m;const s=new Set;for(let y=0;y<size;y++)for(let x=0;x<size;x++){if(b[y][x]===null)continue;for(let dy=-2;dy<=2;dy++)for(let dx=-2;dx<=2;dx++){if(dx===0&&dy===0)continue;const nx=x+dx,ny=y+dy;if(canPlace(nx,ny)&&b[ny][nx]===null)s.add(`${nx},${ny}`)}}return s.forEach(v=>{const[x,y]=v.split(',').map(Number);m.push({x,y})}),m};
  evaluateLine=function(l){let s=0;const a=l.filter(c=>c===aiColor).length,p=l.filter(c=>c===playerColor).length,e=l.filter(c=>c===null).length;return a===4&&e===1?s+=1e4:a===3&&e===2?s+=1e3:a===2&&e===3&&(s+=100),p===4&&e===1?s-=2e4:p===3&&e===2?s-=5e3:p===2&&e===3&&(s-=200),s};
  evaluateBoard=function(b){let t=0;for(let i=0;i<size;i++)for(let j=0;j<size-4;j++)t+=evaluateLine(b[i].slice(j,j+5)),t+=evaluateLine([b[j][i],b[j+1][i],b[j+2][i],b[j+3][i],b[j+4][i]]);for(let i=0;i<size-4;i++)for(let j=0;j<size-4;j++)t+=evaluateLine([b[i][j],b[i+1][j+1],b[i+2][j+2],b[i+3][j+3],b[i+4][j+4]]),t+=evaluateLine([b[i+4][j],b[i+3][j+1],b[i+2][j+2],b[i+1][j+3],b[i][j+4]]);return t};
  minimax=function(b,d,alpha,beta,m,s){if(d===0||Date.now()-s>9500)return evaluateBoard(b);const v=generateMoves(b);if(v.length===0)return 0;if(m){let e=-1/0;for(const o of v){const n=b.map(r=>r.slice());if(n[o.y][o.x]=aiColor,isWinBoard(n,o.x,o.y,aiColor))return 1e6;const c=minimax(n,d-1,alpha,beta,!1,s);e=Math.max(e,c),alpha=Math.max(alpha,c);if(beta<=alpha)break}return e}else{let e=1/0;for(const o of v){const n=b.map(r=>r.slice());if(n[o.y][o.x]=playerColor,isWinBoard(n,o.x,o.y,playerColor))return-1e6;const c=minimax(n,d-1,alpha,beta,!0,s);e=Math.min(e,c),beta=Math.min(beta,c);if(beta<=alpha)break}return e}};
  aiMove=function(){if(gameOver)return;const s=Date.now(),m=generateMoves(board);if(m.length===0)return showMessage("무승부!"),void(gameOver=!0);let b=m[0];for(const o of m){const t=board.map(r=>r.slice());if(t[o.y][o.x]=aiColor,isWinBoard(t,o.x,o.y,aiColor))return b=o,void placeAndCheckWin(b.x,b.y,aiColor)}for(const o of m){const t=board.map(r=>r.slice());if(t[o.y][o.x]=playerColor,isWinBoard(t,o.x,o.y,playerColor))return b=o,void placeAndCheckWin(b.x,b.y,aiColor)}let e=-1/0;for(const o of m){const t=board.map(r=>r.slice());t[o.y][o.x]=aiColor;const c=minimax(t,2,-1/0,1/0,!1,s);c>e&&(e=c,b=o)}placeAndCheckWin(b.x,b.y,aiColor)};

})();
</script>

</body>
</html>
```